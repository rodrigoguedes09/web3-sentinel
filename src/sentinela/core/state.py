"""
Core State Definition for LangGraph Agent Orchestration.

This module defines the AgentState TypedDict that flows through the multi-agent
graph, carrying all context needed for vulnerability discovery and exploitation.
"""

from __future__ import annotations

from dataclasses import dataclass, field
from enum import Enum
from typing import Annotated, Any, TypedDict

from langgraph.graph.message import add_messages
from pydantic import BaseModel, Field


# =============================================================================
# Enumerations
# =============================================================================


class VulnerabilityType(str, Enum):
    """Classification of vulnerability types the system can detect."""

    REENTRANCY = "reentrancy"
    ACCESS_CONTROL = "access_control"
    LOGIC_FLAW = "logic_flaw"
    ORACLE_MANIPULATION = "oracle_manipulation"
    FLASH_LOAN = "flash_loan"
    FRONT_RUNNING = "front_running"
    DENIAL_OF_SERVICE = "denial_of_service"
    INTEGER_OVERFLOW = "integer_overflow"
    UNCHECKED_RETURN = "unchecked_return"
    SIGNATURE_REPLAY = "signature_replay"
    STORAGE_COLLISION = "storage_collision"
    DELEGATECALL_INJECTION = "delegatecall_injection"
    UNINITIALIZED_PROXY = "uninitialized_proxy"
    PRICE_MANIPULATION = "price_manipulation"
    GOVERNANCE_ATTACK = "governance_attack"
    UNKNOWN = "unknown"


class HypothesisStatus(str, Enum):
    """Status of an attack hypothesis through the proving pipeline."""

    PENDING = "pending"
    TESTING = "testing"
    PROVEN = "proven"
    DISPROVEN = "disproven"
    COMPILATION_ERROR = "compilation_error"
    RUNTIME_ERROR = "runtime_error"
    TIMEOUT = "timeout"


class AgentPhase(str, Enum):
    """Current phase in the agent orchestration pipeline."""

    INITIALIZATION = "initialization"
    EXPLORATION = "exploration"
    HYPOTHESIS_GENERATION = "hypothesis_generation"
    EXPLOIT_WRITING = "exploit_writing"
    EXPLOIT_TESTING = "exploit_testing"
    REFLECTION = "reflection"
    REPORTING = "reporting"
    COMPLETED = "completed"
    FAILED = "failed"


# =============================================================================
# Pydantic Models for Structured Outputs
# =============================================================================


class ContractEntryPoint(BaseModel):
    """Represents a critical function entry point in a smart contract."""

    function_name: str = Field(..., description="Name of the function")
    visibility: str = Field(..., description="Function visibility (public, external, etc.)")
    modifiers: list[str] = Field(default_factory=list, description="Applied modifiers")
    parameters: list[str] = Field(default_factory=list, description="Function parameters")
    state_mutability: str = Field(default="nonpayable", description="State mutability")
    risk_score: float = Field(default=0.0, ge=0.0, le=1.0, description="Estimated risk score")
    reasoning: str = Field(default="", description="Why this is a critical entry point")


class SlitherFinding(BaseModel):
    """Represents a finding from Slither static analysis."""

    detector: str = Field(..., description="Slither detector name")
    severity: str = Field(..., description="Impact severity (High, Medium, Low, Info)")
    confidence: str = Field(..., description="Detection confidence")
    description: str = Field(..., description="Finding description")
    contract: str = Field(default="", description="Affected contract name")
    function: str = Field(default="", description="Affected function name")
    lines: list[int] = Field(default_factory=list, description="Affected line numbers")


class AttackHypothesis(BaseModel):
    """A formulated attack hypothesis generated by the Red Teamer."""

    id: str = Field(..., description="Unique hypothesis identifier")
    vulnerability_type: VulnerabilityType = Field(..., description="Type of vulnerability")
    title: str = Field(..., description="Short descriptive title")
    description: str = Field(..., description="Detailed attack description")
    attack_vector: str = Field(..., description="Step-by-step attack vector")
    preconditions: list[str] = Field(default_factory=list, description="Required preconditions")
    target_functions: list[str] = Field(default_factory=list, description="Target functions")
    estimated_impact: str = Field(default="", description="Potential impact if exploited")
    confidence_score: float = Field(default=0.5, ge=0.0, le=1.0, description="Hypothesis confidence")
    similar_hacks: list[str] = Field(default_factory=list, description="Similar historical hacks")
    status: HypothesisStatus = Field(default=HypothesisStatus.PENDING)


class ExploitTest(BaseModel):
    """Represents a generated Foundry exploit test."""

    hypothesis_id: str = Field(..., description="Associated hypothesis ID")
    test_name: str = Field(..., description="Foundry test function name")
    file_path: str = Field(..., description="Path to the .t.sol file")
    solidity_code: str = Field(..., description="Complete Solidity test code")
    setup_code: str = Field(default="", description="Test setup code")
    exploit_code: str = Field(default="", description="Core exploit logic")
    assertion_code: str = Field(default="", description="Assertions to verify exploit")


class TestResult(BaseModel):
    """Result of running a Foundry exploit test."""

    hypothesis_id: str = Field(..., description="Associated hypothesis ID")
    test_name: str = Field(..., description="Test function name")
    success: bool = Field(..., description="Whether the exploit was successful")
    execution_time_ms: int = Field(default=0, description="Execution time in milliseconds")
    gas_used: int = Field(default=0, description="Gas consumed by the test")
    stdout: str = Field(default="", description="Standard output from forge")
    stderr: str = Field(default="", description="Standard error from forge")
    error_type: str | None = Field(default=None, description="Error type if failed")
    error_message: str | None = Field(default=None, description="Error message if failed")
    stack_trace: str | None = Field(default=None, description="Stack trace if available")


class VulnerabilityReport(BaseModel):
    """Final vulnerability report for a proven exploit."""

    hypothesis: AttackHypothesis = Field(..., description="The proven hypothesis")
    exploit_test: ExploitTest = Field(..., description="The successful exploit test")
    test_result: TestResult = Field(..., description="Test execution result")
    severity: str = Field(..., description="Final severity assessment")
    recommendations: list[str] = Field(default_factory=list, description="Remediation recommendations")
    references: list[str] = Field(default_factory=list, description="Reference links")


class ExplorerOutput(BaseModel):
    """Structured output from the Explorer agent."""

    contract_name: str = Field(..., description="Name of the analyzed contract")
    source_hash: str = Field(..., description="Hash of the source code for caching")
    entry_points: list[ContractEntryPoint] = Field(
        default_factory=list, description="Identified critical entry points"
    )
    slither_findings: list[SlitherFinding] = Field(
        default_factory=list, description="Slither static analysis findings"
    )
    control_flow_summary: str = Field(default="", description="Summary of control flow")
    external_calls: list[str] = Field(default_factory=list, description="External contract calls")
    state_variables: list[str] = Field(default_factory=list, description="Key state variables")
    inheritance_chain: list[str] = Field(default_factory=list, description="Contract inheritance")


class RedTeamerOutput(BaseModel):
    """Structured output from the Red Teamer agent."""

    hypotheses: list[AttackHypothesis] = Field(
        default_factory=list, description="Generated attack hypotheses"
    )
    reasoning_chain: str = Field(default="", description="Reasoning behind hypothesis generation")
    rag_context_used: list[str] = Field(
        default_factory=list, description="Historical hacks referenced"
    )


class ReflectionFeedback(BaseModel):
    """Feedback for the reflection loop when tests fail to compile or execute."""

    original_error: str = Field(..., description="Original error message")
    error_category: str = Field(..., description="Category of error (compilation, runtime, logic)")
    suggested_fixes: list[str] = Field(default_factory=list, description="Suggested code fixes")
    should_retry: bool = Field(default=True, description="Whether to retry with fixes")
    iteration_count: int = Field(default=0, description="Current reflection iteration")


# =============================================================================
# LangGraph State Definition
# =============================================================================


class AgentState(TypedDict, total=False):
    """
    Central state object that flows through the LangGraph agent pipeline.
    
    This TypedDict carries all context needed for the multi-agent swarm to
    discover, hypothesize, and prove smart contract vulnerabilities.
    
    Attributes:
        messages: Conversation history with add_messages reducer
        phase: Current orchestration phase
        source_code: Raw Solidity source code being audited
        contract_path: Path to the contract file
        explorer_output: Output from the Explorer agent
        hypotheses: List of attack hypotheses from Red Teamer
        current_hypothesis_index: Index of hypothesis being tested
        exploit_tests: Generated exploit test code
        test_results: Results from running exploit tests
        reflection_feedback: Feedback for the reflection loop
        reflection_count: Number of reflection iterations
        max_reflections: Maximum allowed reflection iterations
        proven_vulnerabilities: Successfully proven vulnerabilities
        final_reports: Generated vulnerability reports
        error: Any error that occurred during processing
        metadata: Additional metadata and configuration
    """

    # Message history for agent communication
    messages: Annotated[list[Any], add_messages]

    # Pipeline state
    phase: AgentPhase
    iteration: int

    # Input contract data
    source_code: str
    contract_path: str
    contract_name: str

    # Explorer outputs
    explorer_output: ExplorerOutput | None
    slither_raw_json: dict[str, Any]

    # Red Teamer outputs
    hypotheses: list[AttackHypothesis]
    current_hypothesis_index: int
    rag_context: list[dict[str, Any]]

    # Prover outputs
    exploit_tests: list[ExploitTest]
    current_exploit_test: ExploitTest | None

    # Test execution
    test_results: list[TestResult]
    current_test_result: TestResult | None

    # Reflection loop
    reflection_feedback: ReflectionFeedback | None
    reflection_count: int
    max_reflections: int

    # Final outputs
    proven_vulnerabilities: list[AttackHypothesis]
    final_reports: list[VulnerabilityReport]

    # Error handling
    error: str | None
    error_traceback: str | None

    # Metadata
    metadata: dict[str, Any]


# =============================================================================
# State Factory Functions
# =============================================================================


def create_initial_state(
    source_code: str,
    contract_path: str,
    contract_name: str = "",
    max_reflections: int = 3,
) -> AgentState:
    """
    Create an initial AgentState for starting the audit pipeline.
    
    Args:
        source_code: The Solidity source code to audit
        contract_path: Path to the contract file
        contract_name: Name of the main contract (optional, can be inferred)
        max_reflections: Maximum reflection loop iterations
        
    Returns:
        Initialized AgentState ready for the pipeline
    """
    return AgentState(
        messages=[],
        phase=AgentPhase.INITIALIZATION,
        iteration=0,
        source_code=source_code,
        contract_path=contract_path,
        contract_name=contract_name,
        explorer_output=None,
        slither_raw_json={},
        hypotheses=[],
        current_hypothesis_index=0,
        rag_context=[],
        exploit_tests=[],
        current_exploit_test=None,
        test_results=[],
        current_test_result=None,
        reflection_feedback=None,
        reflection_count=0,
        max_reflections=max_reflections,
        proven_vulnerabilities=[],
        final_reports=[],
        error=None,
        error_traceback=None,
        metadata={},
    )
